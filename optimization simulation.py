import os
import pyomo.environ as pyomo
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.gridspec import GridSpec
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import datetime
3
def load_data_from_csv(solar_file, load_file):
    """
    Load solar and load data from CSV files with 15-minute timestamps.
    
    Expected CSV format:
    timestamp,power
    2023-01-01 00:00:00,10.5
    2023-01-01 00:15:00,11.2
    ...
    
    Parameters:
    -----------
    solar_file : str
        Path to CSV file with solar generation data
    load_file : str
        Path to CSV file with load demand data
        
    Returns:
    --------
    solar_data : list
        Solar generation values
    load_data : list
        Load demand values
    timestamps : list
        Datetime objects corresponding to the data points
    """
    try:
        # Read CSV files into pandas DataFrames with timestamp parsing
        solar_df = pd.read_csv(solar_file, parse_dates=['timestamp'])
        load_df = pd.read_csv(load_file, parse_dates=['timestamp'])
        
        # Check if files have the expected columns
        if 'timestamp' not in solar_df.columns or 'power' not in solar_df.columns:
            raise ValueError("Solar data CSV must have 'timestamp' and 'power' columns")
        if 'timestamp' not in load_df.columns or 'power' not in load_df.columns:
            raise ValueError("Load data CSV must have 'timestamp' and 'power' columns")
            
        # Use timestamps from solar data as the reference
        timestamps = solar_df['timestamp'].tolist()
        solar_data = solar_df['power'].tolist()
        
        # Align load data with solar timestamps
        # This step ensures both datasets have the same timestamps
        aligned_load = pd.merge(
            pd.DataFrame({'timestamp': timestamps}),
            load_df,
            on='timestamp',
            how='left'
        )
        
        # Fill any missing values with zeros or interpolate
        aligned_load['power'].fillna(method='ffill', inplace=True)
        aligned_load['power'].fillna(0, inplace=True)
        
        load_data = aligned_load['power'].tolist()
        
        return solar_data, load_data, timestamps
        
    except Exception as e:
        print(f"Error loading data: {e}")
        # Return some sample data if loading fails
        print("Using sample data instead")
        
        # Create sample timestamps at 15-minute intervals for one day
        start_time = datetime.datetime(2023, 1, 1, 0, 0)
        timestamps = [start_time + datetime.timedelta(minutes=15*i) for i in range(96)]  # 96 points = 24 hours
        
        # Create sample solar data (bell curve peaking at noon)
        solar_data = []
        for i in range(96):
            hour = (i * 15) / 60  # Convert to hour of day
            if 6 <= hour <= 18:  # Daylight hours
                solar_val = 100 * np.sin(np.pi * (hour - 6) / 12)
                solar_data.append(max(0, solar_val))
            else:
                solar_data.append(0)
                
        # Create sample load data (two peaks: morning and evening)
        load_data = []
        for i in range(96):
            hour = (i * 15) / 60
            # Morning peak (7-9 AM)
            morning = 50 * np.exp(-0.5 * ((hour - 8) / 1) ** 2)
            # Evening peak (6-8 PM)
            evening = 70 * np.exp(-0.5 * ((hour - 19) / 1) ** 2)
            # Base load
            base = 30
            load_data.append(base + morning + evening)
            
        return solar_data, load_data, timestamps

def optimization_model(solar_data, load_data, grid_limit, bess_params, time_steps, 
                       diesel_enabled=True, diesel_max=100, diesel_price=0.3, grid_price=0.15,
                       peak_threshold=None, peak_penalty=10.0):
    """
    Optimize power dispatch for a star topology network.
    
    Parameters:
    -----------
    solar_data : list
        Power generated by the PV system at each time step (kW)
    load_data : list
        Load demand at each time step (kW)
    grid_limit : float
        Maximum grid import/export limit (kW)
    bess_params : dict
        Battery parameters including capacity, charge/discharge rates, efficiency
    time_steps : int
        Number of time steps in the optimization horizon
    diesel_enabled : bool, optional
        Whether to include diesel generator in the model (default: True)
    diesel_max : float, optional
        Maximum diesel generator output (kW) (used only when diesel_enabled=True)
    diesel_price : float, optional
        Price of electricity from diesel generator ($/kWh) (used only when diesel_enabled=True)
    grid_price : float, optional
        Price of electricity from the grid ($/kWh)
    peak_threshold : float, optional
        Threshold for peak demand (kW), used for peak shaving objective
    peak_penalty : float, optional
        Penalty factor for exceeding peak threshold ($)
    
    Returns:
    --------
    model : Pyomo ConcreteModel
        The solved optimization model
    result : dict
        Dictionary containing the optimization results
    """
    # Create a new Pyomo model
    model = pyomo.ConcreteModel()
    
    # Define the set of time steps
    model.T = pyomo.Set(initialize=range(time_steps))
    
    # ------ Define parameters ------
    # Convert input data to dictionaries for Pyomo
    solar_dict = {t: solar_data[t] for t in range(time_steps)}
    load_dict = {t: load_data[t] for t in range(time_steps)}
    
    # Solar power data
    model.solar_data = pyomo.Param(model.T, initialize=solar_dict)
    
    # Load data
    model.load_data = pyomo.Param(model.T, initialize=load_dict)
    
    # Grid parameters
    model.grid_limit = pyomo.Param(initialize=grid_limit)  # Maximum grid import/export (kW)
    model.grid_price = pyomo.Param(initialize=grid_price)  # Grid electricity price ($/kWh)
    
    # Diesel parameters (only if enabled)
    if diesel_enabled:
        model.diesel_max = pyomo.Param(initialize=diesel_max)  # Maximum diesel output (kW)
        model.diesel_price = pyomo.Param(initialize=diesel_price)  # Diesel generation price ($/kWh)
    
    # BESS parameters
    model.bess_capacity = pyomo.Param(initialize=bess_params['capacity'])  # Battery capacity (kWh)
    model.bess_charge_max = pyomo.Param(initialize=bess_params['charge_max'])  # Max charging rate (kW)
    model.bess_discharge_max = pyomo.Param(initialize=bess_params['discharge_max'])  # Max discharging rate (kW)
    model.bess_efficiency = pyomo.Param(initialize=bess_params['efficiency'])  # Battery efficiency
    model.bess_min_soc = pyomo.Param(initialize=bess_params['min_soc'])  # Minimum SOC fraction
    model.bess_max_soc = pyomo.Param(initialize=bess_params['max_soc'])  # Maximum SOC fraction
    model.bess_initial_soc = pyomo.Param(initialize=bess_params['initial_soc'])  # Initial SOC (kWh)
    
    # Time step duration (15 minutes = 0.25 hours)
    model.time_step = pyomo.Param(initialize=0.25)
    
    # Peak shaving parameters
    if peak_threshold is not None:
        model.peak_threshold = pyomo.Param(initialize=peak_threshold)  # Peak demand threshold (kW)
        model.peak_penalty = pyomo.Param(initialize=peak_penalty)  # Penalty for exceeding threshold ($/kW)
    
    # ------ Define variables ------
    # Power from solar panels to different destinations (all non-negative)
    model.p_solar_to_load = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Solar power directly to load
    model.p_solar_to_bess = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Solar power to battery
    model.p_solar_to_grid = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Solar power to grid
    
    # Grid power flow (positive = import, negative = export)
    model.p_grid = pyomo.Var(model.T, domain=pyomo.Reals)  # Net grid power
    model.p_grid_import = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Grid import
    model.p_grid_export = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Grid export
    
    # Diesel generator output (only if enabled)
    if diesel_enabled:
        model.p_diesel = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Diesel power output
        model.diesel_on = pyomo.Var(model.T, domain=pyomo.Binary)  # 1 if diesel is on, 0 otherwise
    else:
        # Create dummy variables with fixed value 0 (for consistency in the model)
        model.p_diesel = pyomo.Var(model.T, domain=pyomo.NonNegativeReals, initialize=0)
        model.diesel_on = pyomo.Var(model.T, domain=pyomo.Binary, initialize=0)
        
        # Fix these variables to 0 to prevent them from being decision variables
        for t in model.T:
            model.p_diesel[t].fix(0)
            model.diesel_on[t].fix(0)
    
    # Battery power flow (separate charge and discharge for clarity)
    model.p_bess_charge = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Battery charging power
    model.p_bess_discharge = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Battery discharging power
    model.bess_charging = pyomo.Var(model.T, domain=pyomo.Binary)  # 1 if charging, 0 if discharging
    
    # Battery state of charge
    model.soc = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Battery state of charge (kWh)
    
    # Grid export status
    model.grid_export = pyomo.Var(model.T, domain=pyomo.Binary)  # 1 if exporting to grid, 0 otherwise
    
    # Peak demand variables (if peak shaving is enabled)
    if peak_threshold is not None:
        model.peak_demand = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Net power from grid at each time
        model.peak_excess = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)  # Amount exceeding threshold
    
    # ------ Define objective function ------
    def obj_rule(model):
        # Grid import cost (buying electricity)
        grid_cost = sum(model.p_grid_import[t] * model.grid_price * model.time_step for t in model.T)
        
        # Grid export revenue (selling electricity)
        grid_revenue = sum(model.p_grid_export[t] * model.grid_price * 0.8 * model.time_step for t in model.T)  # Assume 80% of price for export
        
        # Diesel generation cost (if enabled)
        diesel_cost = 0
        if diesel_enabled:
            diesel_cost = sum(model.p_diesel[t] * model.diesel_price * model.time_step for t in model.T)
        
        # Peak shaving penalty (if enabled)
        peak_penalty = 0
        if peak_threshold is not None:
            peak_penalty = sum(model.peak_excess[t] * model.peak_penalty for t in model.T)
        
        # Objective: minimize costs - revenue + penalties
        return grid_cost + diesel_cost - grid_revenue + peak_penalty
    
    # Set the objective function
    model.objective = pyomo.Objective(rule=obj_rule, sense=pyomo.minimize)
    
    # ------ Define constraints ------
    # 1. Solar power distribution constraint
    # Total solar power utilized cannot exceed available solar power
    def solar_balance_rule(model, t):
        return model.p_solar_to_load[t] + model.p_solar_to_bess[t] + model.p_solar_to_grid[t] <= model.solar_data[t]
    model.solar_balance = pyomo.Constraint(model.T, rule=solar_balance_rule)
    
    # 2. Grid power decomposition constraint
    # Net grid power equals imports minus exports
    def grid_decomposition_rule(model, t):
        return model.p_grid[t] == model.p_grid_import[t] - model.p_grid_export[t]
    model.grid_decomposition = pyomo.Constraint(model.T, rule=grid_decomposition_rule)
    
    # 3. Power balance constraint (Kirchhoff's law at the node)
    # Sum of all power flows must be zero
    def power_balance_rule(model, t):
        # Sources (positive): solar to load, solar to grid, diesel, grid import, battery discharge
        # Sinks (negative): load, grid export, battery charge
        power_in = model.p_solar_to_load[t] + model.p_grid_import[t] + model.p_diesel[t] + model.p_bess_discharge[t]
        power_out = model.load_data[t] + model.p_grid_export[t] + model.p_bess_charge[t]
        return power_in == power_out
    model.power_balance = pyomo.Constraint(model.T, rule=power_balance_rule)
    
    # 4. Load constraint
    # The load must be fully satisfied at all times
    def load_constraint_rule(model, t):
        return model.p_solar_to_load[t] + model.p_grid_import[t] + model.p_diesel[t] + model.p_bess_discharge[t] >= model.load_data[t]
    model.load_constraint = pyomo.Constraint(model.T, rule=load_constraint_rule)
    
    # 5. Grid limit constraints
    # Grid import/export cannot exceed the grid limit
    def grid_import_limit_rule(model, t):
        return model.p_grid_import[t] <= model.grid_limit * (1 - model.grid_export[t])
    model.grid_import_limit = pyomo.Constraint(model.T, rule=grid_import_limit_rule)
    
    def grid_export_limit_rule(model, t):
        return model.p_grid_export[t] <= model.grid_limit * model.grid_export[t]
    model.grid_export_limit = pyomo.Constraint(model.T, rule=grid_export_limit_rule)
    
    # 6. Diesel constraints (if enabled)
    if diesel_enabled:
        # Diesel output limit
        def diesel_limit_rule(model, t):
            return model.p_diesel[t] <= model.diesel_max * model.diesel_on[t]
        model.diesel_limit = pyomo.Constraint(model.T, rule=diesel_limit_rule)
        
        # Diesel cannot send power to grid (critical constraint)
        def diesel_grid_rule(model, t):
            return model.diesel_on[t] + model.grid_export[t] <= 1
        model.diesel_grid = pyomo.Constraint(model.T, rule=diesel_grid_rule)
    
    # 7. Battery constraints
    # Battery power flow relationship (only one of charge/discharge at a time)
    def bess_charge_rule(model, t):
        return model.p_bess_charge[t] <= model.bess_charge_max * model.bess_charging[t]
    model.bess_charge_constraint = pyomo.Constraint(model.T, rule=bess_charge_rule)
    
    def bess_discharge_rule(model, t):
        return model.p_bess_discharge[t] <= model.bess_discharge_max * (1 - model.bess_charging[t])
    model.bess_discharge_constraint = pyomo.Constraint(model.T, rule=bess_discharge_rule)
    
    # Battery state of charge dynamics
    def soc_dynamics_rule(model, t):
        if t == 0:
            # For the first time step, use the initial SOC
            return model.soc[t] == model.bess_initial_soc + \
                   (model.p_bess_charge[t] * model.bess_efficiency - model.p_bess_discharge[t] / model.bess_efficiency) * model.time_step
        else:
            # For subsequent time steps, use the SOC from the previous time step
            return model.soc[t] == model.soc[t-1] + \
                   (model.p_bess_charge[t] * model.bess_efficiency - model.p_bess_discharge[t] / model.bess_efficiency) * model.time_step
    model.soc_dynamics = pyomo.Constraint(model.T, rule=soc_dynamics_rule)
    
    # Battery SOC limits
    def soc_min_rule(model, t):
        return model.soc[t] >= model.bess_min_soc * model.bess_capacity
    model.soc_min = pyomo.Constraint(model.T, rule=soc_min_rule)
    
    def soc_max_rule(model, t):
        return model.soc[t] <= model.bess_max_soc * model.bess_capacity
    model.soc_max = pyomo.Constraint(model.T, rule=soc_max_rule)
    
    # End of horizon constraint - leave the battery at a reasonable SOC
    def soc_final_rule(model):
        # Target at least 50% SOC at the end, unless initial was lower
        target_soc = max(0.5 * model.bess_capacity, model.bess_initial_soc) 
        return model.soc[model.T.last()] >= target_soc
    model.soc_final = pyomo.Constraint(rule=soc_final_rule)
    
    # 8. Peak shaving constraints (if enabled)
    if peak_threshold is not None:
        # Define peak demand at each time step
        def peak_demand_rule(model, t):
            return model.peak_demand[t] == model.p_grid_import[t]
        model.peak_demand_def = pyomo.Constraint(model.T, rule=peak_demand_rule)
        
        # Calculate excess above threshold
        def peak_excess_rule(model, t):
            return model.peak_excess[t] >= model.peak_demand[t] - model.peak_threshold
        model.peak_excess_def = pyomo.Constraint(model.T, rule=peak_excess_rule)
    
    # Constraint to ensure no fictitious flow: solar directly to battery, not via grid
    def direct_solar_to_bess_rule(model, t):
        return model.p_solar_to_bess[t] == model.p_bess_charge[t] * model.bess_charging[t]
    model.direct_solar_to_bess = pyomo.Constraint(model.T, rule=direct_solar_to_bess_rule)
    
    # ------ Solve the model ------
    try:
        # First try Gurobi
        solver = pyomo.SolverFactory('gurobi')
        solver.options['TimeLimit'] = 300  # 5-minute time limit
        solver.options['MIPGap'] = 0.01    # 1% MIP gap tolerance
        results = solver.solve(model, tee=True)  # tee=True shows solver output
    except:
        try:
            # Fall back to GLPK if Gurobi is not available
            print("Gurobi not available, trying GLPK instead")
            solver = pyomo.SolverFactory('glpk')
            results = solver.solve(model, tee=True)
        except:
            # Fall back to CBC if GLPK is not available
            print("GLPK not available, trying CBC instead")
            solver = pyomo.SolverFactory('cbc')
            results = solver.solve(model, tee=True)
    
    # Check if the solve was successful
    if results.solver.status == pyomo.SolverStatus.ok and \
       results.solver.termination_condition == pyomo.TerminationCondition.optimal:
        print("Optimization successful!")
    else:
        print(f"Warning: Optimization might not be optimal. Status: {results.solver.status}, Termination condition: {results.solver.termination_condition}")
    
    # ------ Extract results ------
    # Create a dictionary to store all the results
    result = {
        # Solar flows
        'p_solar': [model.solar_data[t] for t in model.T],
        'p_solar_to_load': [model.p_solar_to_load[t].value for t in model.T],
        'p_solar_to_bess': [model.p_solar_to_bess[t].value for t in model.T],
        'p_solar_to_grid': [model.p_solar_to_grid[t].value for t in model.T],
        
        # Grid flows
        'p_grid': [model.p_grid[t].value for t in model.T],
        'p_grid_import': [model.p_grid_import[t].value for t in model.T],
        'p_grid_export': [model.p_grid_export[t].value for t in model.T],
        
        # Diesel output (zero if disabled)
        'p_diesel': [model.p_diesel[t].value for t in model.T],
        'diesel_on': [model.diesel_on[t].value for t in model.T],
        
        # Battery flows
        'p_bess_charge': [model.p_bess_charge[t].value for t in model.T],
        'p_bess_discharge': [model.p_bess_discharge[t].value for t in model.T],
        'soc': [model.soc[t].value for t in model.T],
        'bess_charging': [model.bess_charging[t].value for t in model.T],
        
        # Grid export status
        'grid_export': [model.grid_export[t].value for t in model.T],
        
        # Objective value
        'objective': model.objective()
    }
    
    # Add peak shaving results if enabled
    if peak_threshold is not None:
        result['peak_demand'] = [model.peak_demand[t].value for t in model.T]
        result['peak_excess'] = [model.peak_excess[t].value for t in model.T]
    
    # Calculate some additional metrics
    # Load data
    result['load'] = load_data
    
    # Self-consumption metrics
    total_solar = sum(result['p_solar'])
    total_load = sum(result['load'])
    solar_to_load = sum(result['p_solar_to_load'])
    solar_to_bess = sum(result['p_solar_to_bess'])
    self_consumed_solar = solar_to_load + solar_to_bess
    
    result['metrics'] = {
        'total_solar_generation': total_solar,
        'total_load': total_load,
        'solar_to_load_direct': solar_to_load,
        'solar_to_battery': solar_to_bess,
        'solar_to_grid': sum(result['p_solar_to_grid']),
        'self_consumption_rate': (self_consumed_solar / total_solar) * 100 if total_solar > 0 else 0,
        'solar_utilization': (solar_to_load / total_load) * 100 if total_load > 0 else 0,
        'grid_imports': sum(result['p_grid_import']),
        'grid_exports': sum(result['p_grid_export']),
        'diesel_generation': sum(result['p_diesel']),
        'peak_grid_import': max(result['p_grid_import']),
        'battery_cycles': sum(result['p_bess_discharge']) / (2 * bess_params['capacity']),
        'objective_value': result['objective']
    }
    
    return model, result

def calculate_metrics(result, solar_data, load_data):
    """
    Calculate key performance metrics from optimization results.
    
    Parameters:
    -----------
    result : dict
        Dictionary containing optimization results
    solar_data : list
        Solar generation data used in the optimization
    load_data : list
        Load demand data used in the optimization
        
    Returns:
    --------
    metrics : dict
        Dictionary containing calculated metrics
    """
    # Some metrics are already calculated in the optimization_model function
    # This function could be extended with additional metrics as needed
    return result['metrics']

def plot_energy_flows(result, solar_data, load_data, timestamps, diesel_enabled=True, peak_threshold=None):
    """
    Create a detailed visualization of energy flows.
    
    Parameters:
    -----------
    result : dict
        Dictionary containing optimization results
    solar_data : list
        Solar generation data used in the optimization
    load_data : list
        Load demand data used in the optimization
    timestamps : list
        List of datetime objects corresponding to the data points
    diesel_enabled : bool, optional
        Whether diesel generator was enabled in the optimization
    peak_threshold : float, optional
        Threshold used for peak shaving, if applicable
    """
    # Create figure with subplots
    fig = plt.figure(figsize=(15, 12))
    gs = GridSpec(3, 1, height_ratios=[2, 1, 1], figure=fig)
    
    # Power flow subplot 
    ax1 = fig.add_subplot(gs[0])
    
    # Plot solar generation (stacked components)
    ax1.fill_between(timestamps, 0, result['p_solar_to_load'], color='gold', alpha=0.8, label='Solar to Load')
    ax1.fill_between(timestamps, result['p_solar_to_load'], 
                     [result['p_solar_to_load'][i] + result['p_solar_to_bess'][i] for i in range(len(timestamps))], 
                     color='gold', alpha=0.5, label='Solar to Battery')
    ax1.fill_between(timestamps, [result['p_solar_to_load'][i] + result['p_solar_to_bess'][i] for i in range(len(timestamps))],
                     [result['p_solar_to_load'][i] + result['p_solar_to_bess'][i] + result['p_solar_to_grid'][i] for i in range(len(timestamps))],
                     color='gold', alpha=0.3, label='Solar to Grid')
    
    # Plot grid imports (positive values only)
    ax1.plot(timestamps, result['p_grid_import'], color='blue', linestyle='-', linewidth=2, label='Grid Import')
    
    # Plot diesel generation (if enabled)
    if diesel_enabled:
        ax1.plot(timestamps, result['p_diesel'], color='brown', linestyle='-', linewidth=2, label='Diesel')
    
    # Plot battery discharge
    ax1.plot(timestamps, result['p_bess_discharge'], color='green', linestyle='-', linewidth=2, label='Battery Discharge')
    
    # Plot load demand
    ax1.plot(timestamps, load_data, color='red', linestyle='-', linewidth=2, label='Load Demand')
    
    # Plot grid exports as negative values
    ax1.plot(timestamps, [-x for x in result['p_grid_export']], color='blue', linestyle='--', linewidth=2, label='Grid Export')
    
    # Plot battery charge as negative values
    ax1.plot(timestamps, [-x for x in result['p_bess_charge']], color='green', linestyle='--', linewidth=2, label='Battery Charge')
    
    # Plot peak threshold if applicable
    if peak_threshold is not None:
        ax1.axhline(y=peak_threshold, color='black', linestyle='--', label=f'Peak Threshold ({peak_threshold} kW)')
    
    # Add labels and legend
    ax1.set_title('Power Flows', fontsize=14)
    ax1.set_ylabel('Power (kW)', fontsize=12)
    ax1.grid(True, alpha=0.3)
    ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    
    # Format x-axis for readable dates
    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
    
    # Battery state of charge subplot
    ax2 = fig.add_subplot(gs[1], sharex=ax1)
    
    # Plot battery SOC
    ax2.plot(timestamps, result['soc'], color='purple', linestyle='-', linewidth=2, label='Battery SOC')
    
    # Add min and max SOC lines
    min_soc = min(result['soc'])
    max_soc = max(result['soc'])
    ax2.axhline(y=min_soc, color='purple', linestyle='--', alpha=0.5, label=f'Min SOC ({min_soc:.1f} kWh)')
    ax2.axhline(y=max_soc, color='purple', linestyle='--', alpha=0.5, label=f'Max SOC ({max_soc:.1f} kWh)')
    
    # Add labels and legend
    ax2.set_title('Battery State of Charge', fontsize=14)
    ax2.set_ylabel('Energy (kWh)', fontsize=12)
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    
    # Control variables subplot
    ax3 = fig.add_subplot(gs[2], sharex=ax1)
    
    # Plot binary control variables
    if diesel_enabled:
        ax3.step(timestamps, result['diesel_on'], color='brown', linestyle='-', linewidth=2, label='Diesel On')
    ax3.step(timestamps, result['grid_export'], color='blue', linestyle='-', linewidth=2, label='Grid Export')
    ax3.step(timestamps, result['bess_charging'], color='green', linestyle='-', linewidth=2, label='Battery Charging')
    
    # Add labels and legend
    ax3.set_title('Control Variables', fontsize=14)
    ax3.set_ylabel('Status (0/1)', fontsize=12)
    ax3.set_xlabel('Time', fontsize=12)
    ax3.set_ylim(-0.1, 1.1)
    ax3.grid(True, alpha=0.3)
    ax3.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    
    plt.tight_layout()
    
    return fig

def plot_interactive_dashboard(result, solar_data, load_data, timestamps, diesel_enabled=True, peak_threshold=None):
    """
    Create an interactive dashboard using Plotly.
    
    Parameters:
    -----------
    result : dict
        Dictionary containing optimization results
    solar_data : list
        Solar generation data used in the optimization
    load_data : list
        Load demand data used in the optimization
    timestamps : list
        List of datetime objects corresponding to the data points
    diesel_enabled : bool, optional
        Whether diesel generator was enabled in the optimization
    peak_threshold : float, optional
        Threshold used for peak shaving, if applicable
        
    Returns:
    --------
    fig : plotly.graph_objects.Figure
        Interactive Plotly figure
    """
    # Create figure with subplots
    fig = make_subplots(rows=3, cols=1, 
                       shared_xaxes=True, 
                       vertical_spacing=0.05,
                       subplot_titles=('Power Flows', 'Battery State of Charge', 'Control Variables'),
                       row_heights=[0.5, 0.25, 0.25])
    
    # 1. Power Flows subplot
    # Solar power components
    fig.add_trace(go.Scatter(x=timestamps, y=result['p_solar_to_load'], 
                             fill=None, mode='lines', line=dict(color='gold', width=0),
                             name='Solar to Load',
                             stackgroup='solar'), row=1, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=result['p_solar_to_bess'], 
                             fill=None, mode='lines', line=dict(color='gold', width=0),
                             name='Solar to Battery',
                             opacity=0.7,
                             stackgroup='solar'), row=1, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=result['p_solar_to_grid'], 
                             fill=None, mode='lines', line=dict(color='gold', width=0),
                             name='Solar to Grid',
                             opacity=0.4,
                             stackgroup='solar'), row=1, col=1)
    
    # Grid, battery and load
    fig.add_trace(go.Scatter(x=timestamps, y=result['p_grid_import'], 
                            mode='lines', line=dict(color='blue', width=2),
                            name='Grid Import'), row=1, col=1)
    
    # Add diesel if enabled
    if diesel_enabled:
        fig.add_trace(go.Scatter(x=timestamps, y=result['p_diesel'], 
                                mode='lines', line=dict(color='brown', width=2),
                                name='Diesel Generation'), row=1, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=result['p_bess_discharge'], 
                            mode='lines', line=dict(color='green', width=2),
                            name='Battery Discharge'), row=1, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=load_data, 
                            mode='lines', line=dict(color='red', width=3),
                            name='Load Demand'), row=1, col=1)
    
    # Grid export and battery charge (shown as negative values)
    fig.add_trace(go.Scatter(x=timestamps, y=[-x for x in result['p_grid_export']], 
                            mode='lines', line=dict(color='blue', width=2, dash='dash'),
                            name='Grid Export'), row=1, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=[-x for x in result['p_bess_charge']], 
                            mode='lines', line=dict(color='green', width=2, dash='dash'),
                            name='Battery Charge'), row=1, col=1)
    
    # Add peak threshold if applicable
    if peak_threshold is not None:
        fig.add_trace(go.Scatter(x=[timestamps[0], timestamps[-1]], y=[peak_threshold, peak_threshold], 
                                mode='lines', line=dict(color='black', width=2, dash='dash'),
                                name=f'Peak Threshold ({peak_threshold} kW)'), row=1, col=1)
    
    # 2. Battery SOC subplot
    fig.add_trace(go.Scatter(x=timestamps, y=result['soc'], 
                            mode='lines', line=dict(color='purple', width=3),
                            name='Battery SOC'), row=2, col=1)
    
    # 3. Control Variables subplot
    if diesel_enabled:
        fig.add_trace(go.Scatter(x=timestamps, y=result['diesel_on'], 
                                mode='lines', line=dict(color='brown', width=2, shape='hv'),
                                name='Diesel On'), row=3, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=result['grid_export'], 
                            mode='lines', line=dict(color='blue', width=2, shape='hv'),
                            name='Grid Export'), row=3, col=1)
    
    fig.add_trace(go.Scatter(x=timestamps, y=result['bess_charging'], 
                            mode='lines', line=dict(color='green', width=2, shape='hv'),
                            name='Battery Charging'), row=3, col=1)
    
    # Update layout and axes
    fig.update_layout(
        title_text="Energy System Optimization Results",
        height=900,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    
    fig.update_xaxes(title_text="Time", row=3, col=1)
    fig.update_yaxes(title_text="Power (kW)", row=1, col=1)
    fig.update_yaxes(title_text="Energy (kWh)", row=2, col=1)
    fig.update_yaxes(title_text="Status (0/1)", range=[-0.1, 1.1], row=3, col=1)
    
    return fig

def display_metrics_table(metrics):
    """
    Create a formatted display of the calculated metrics.
    
    Parameters:
    -----------
    metrics : dict
        Dictionary containing the calculated metrics
    """
    # Print metrics in a formatted table
    print("\n==== Performance Metrics ====")
    print(f"Total Solar Generation: {metrics['total_solar_generation']:.2f} kWh")
    print(f"Total Load: {metrics['total_load']:.2f} kWh")
    print(f"Solar Self-Consumption Rate: {metrics['self_consumption_rate']:.2f}%")
    print(f"Solar Utilization (Load Coverage): {metrics['solar_utilization']:.2f}%")
    print(f"Grid Imports: {metrics['grid_imports']:.2f} kWh")
    print(f"Grid Exports: {metrics['grid_exports']:.2f} kWh")
    print(f"Diesel Generation: {metrics['diesel_generation']:.2f} kWh")
    print(f"Peak Grid Import: {metrics['peak_grid_import']:.2f} kW")
    print(f"Battery Cycles: {metrics['battery_cycles']:.2f}")
    print(f"Total Cost: ${metrics['objective_value']:.2f}")
    print("============================")

def create_sample_data(duration_days=1, interval_minutes=15, include_timestamps=True):
    """
    Create sample data for testing when no CSV files are available.
    
    Parameters:
    -----------
    duration_days : int, optional
        Duration of the simulation in days
    interval_minutes : int, optional
        Time interval in minutes
    include_timestamps : bool, optional
        Whether to include timestamps in the output
        
    Returns:
    --------
    sample_data : dict
        Dictionary containing sample solar, load, and timestamp data
    """
    # Calculate number of data points
    points_per_day = 24 * 60 // interval_minutes
    num_points = points_per_day * duration_days
    
    # Create timestamps
    start_time = datetime.datetime(2023, 1, 1, 0, 0)
    timestamps = [start_time + datetime.timedelta(minutes=interval_minutes*i) for i in range(num_points)]
    
    # Create sample solar data (bell curve for each day)
    solar_data = []
    for i in range(num_points):
        day_point = i % points_per_day
        hour = (day_point * interval_minutes) / 60  # Hour of the day
        
        if 6 <= hour <= 18:  # Daylight hours
            # Bell curve with peak at noon (hour 12)
            peak_capacity = 100  # kW
            solar_val = peak_capacity * np.exp(-0.5 * ((hour - 12) / 3) ** 2)
            # Add some randomness
            solar_val *= (0.8 + 0.4 * np.random.random())
            solar_data.append(max(0, solar_val))
        else:
            solar_data.append(0)
    
    # Create sample load data (two peaks: morning and evening)
    load_data = []
    for i in range(num_points):
        day_point = i % points_per_day
        hour = (day_point * interval_minutes) / 60
        
        # Morning peak (7-9 AM)
        morning = 40 * np.exp(-0.5 * ((hour - 8) / 1) ** 2)
        # Evening peak (6-8 PM)
        evening = 60 * np.exp(-0.5 * ((hour - 19) / 1) ** 2)
        # Base load
        base = 20 + 5 * np.sin(2 * np.pi * i / points_per_day)  # Slight variation throughout the day
        
        # Add some randomness
        randomness = 0.9 + 0.2 * np.random.random()
        load_val = (base + morning + evening) * randomness
        load_data.append(max(10, load_val))  # Minimum load of 10
    
    # Create sample data dictionary
    sample_data = {
        'solar_data': solar_data,
        'load_data': load_data
    }
    
    if include_timestamps:
        sample_data['timestamps'] = timestamps
        
    return sample_data

def save_sample_data_to_csv(output_dir='.'):
    """
    Generate sample data and save to CSV files for testing.
    
    Parameters:
    -----------
    output_dir : str, optional
        Directory to save the CSV files
        
    Returns:
    --------
    file_paths : tuple
        Tuple containing the paths to the generated files (solar_file, load_file)
    """
    # Generate sample data
    sample_data = create_sample_data(duration_days=1, interval_minutes=15)
    
    # Create DataFrames
    solar_df = pd.DataFrame({
        'timestamp': sample_data['timestamps'],
        'power': sample_data['solar_data']
    })
    
    load_df = pd.DataFrame({
        'timestamp': sample_data['timestamps'],
        'power': sample_data['load_data']
    })
    
    # Create directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Save to CSV
    solar_file = os.path.join(output_dir, 'solar_data.csv')
    load_file = os.path.join(output_dir, 'load_data.csv')
    
    solar_df.to_csv(solar_file, index=False)
    load_df.to_csv(load_file, index=False)
    
    print(f"Sample data saved to {solar_file} and {load_file}")
    return solar_file, load_file

def run_simulation(solar_file=None, load_file=None, diesel_enabled=True, diesel_max=100, 
                  grid_limit=200, bess_params=None, grid_price=0.15, diesel_price=0.3,
                  peak_threshold=None, peak_penalty=10.0, use_sample_data=False,
                  save_plots=False, output_dir='.', interactive=True):
    """
    Run the complete energy optimization simulation.
    
    Parameters:
    -----------
    solar_file : str, optional
        Path to CSV file with solar generation data
    load_file : str, optional
        Path to CSV file with load demand data
    diesel_enabled : bool, optional
        Whether to include diesel generator in the model
    diesel_max : float, optional
        Maximum diesel generator output (kW)
    grid_limit : float, optional
        Maximum grid import/export limit (kW)
    bess_params : dict, optional
        Battery parameters
    grid_price : float, optional
        Price of electricity from the grid ($/kWh)
    diesel_price : float, optional
        Price of electricity from diesel generator ($/kWh)
    peak_threshold : float, optional
        Threshold for peak demand (kW), used for peak shaving
    peak_penalty : float, optional
        Penalty factor for exceeding peak threshold ($)
    use_sample_data : bool, optional
        Whether to use generated sample data instead of CSV files
    save_plots : bool, optional
        Whether to save plots to files
    output_dir : str, optional
        Directory to save output files
    interactive : bool, optional
        Whether to use interactive Plotly plots
        
    Returns:
    --------
    results : dict
        Dictionary containing optimization results and metrics
    """
    # Default battery parameters if not provided
    if bess_params is None:
        bess_params = {
            'capacity': 200,         # Battery capacity (kWh)
            'charge_max': 50,        # Maximum charging rate (kW)
            'discharge_max': 50,     # Maximum discharging rate (kW)
            'efficiency': 0.95,      # Battery efficiency
            'min_soc': 0.1,          # Minimum SOC (fraction of capacity)
            'max_soc': 0.9,          # Maximum SOC (fraction of capacity)
            'initial_soc': 100       # Initial SOC (kWh)
        }
    
    # Create output directory if it doesn't exist
    if save_plots and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Load data from CSV files or use sample data
    if use_sample_data or (solar_file is None and load_file is None):
        print("Using sample data for simulation.")
        if solar_file is None and load_file is None and save_plots:
            # Generate and save sample data if needed
            solar_file, load_file = save_sample_data_to_csv(output_dir)
        else:
            # Just use sample data in memory
            sample_data = create_sample_data()
            solar_data = sample_data['solar_data']
            load_data = sample_data['load_data']
            timestamps = sample_data['timestamps']
    else:
        # Load data from CSV files
        solar_data, load_data, timestamps = load_data_from_csv(solar_file, load_file)
    
    # Run optimization model
    model, result = optimization_model(
        solar_data, load_data, grid_limit, bess_params, len(solar_data),
        diesel_enabled, diesel_max, diesel_price, grid_price,
        peak_threshold, peak_penalty
    )
    
    # Calculate metrics
    metrics = calculate_metrics(result, solar_data, load_data)
    
    # Display metrics
    display_metrics_table(metrics)
    
    # Plot results
    if interactive:
        fig = plot_interactive_dashboard(result, solar_data, load_data, timestamps, diesel_enabled, peak_threshold)
        fig.show()
        if save_plots:
            fig.write_html(os.path.join(output_dir, 'energy_dashboard.html'))
    else:
        fig = plot_energy_flows(result, solar_data, load_data, timestamps, diesel_enabled, peak_threshold)
        if save_plots:
            fig.savefig(os.path.join(output_dir, 'energy_flows.png'), dpi=300, bbox_inches='tight')
        plt.show()
    
    # Return results for further analysis
    return {
        'model': model,
        'result': result,
        'metrics': metrics,
        'solar_data': solar_data,
        'load_data': load_data,
        'timestamps': timestamps
    }

# Main execution block
if __name__ == "__main__":
    # Default parameters
    diesel_enabled = True  # Set to False to disable diesel generator
    diesel_max = 50        # Maximum diesel output (kW)
    grid_limit = 100       # Maximum grid power (kW)
    
    # Battery parameters
    bess_params = {
        'capacity': 200,         # Battery capacity (kWh)
        'charge_max': 50,        # Maximum charging rate (kW)
        'discharge_max': 50,     # Maximum discharging rate (kW)
        'efficiency': 0.95,      # Battery efficiency
        'min_soc': 0.1,          # Minimum SOC (fraction of capacity)
        'max_soc': 0.9,          # Maximum SOC (fraction of capacity)
        'initial_soc': 100       # Initial SOC (kWh)
    }
    
    # Use sample data with interactive plots
    # If you have actual CSV files, replace these with your file paths
    results = run_simulation(
        diesel_enabled=diesel_enabled,
        diesel_max=diesel_max,
        grid_limit=grid_limit,
        bess_params=bess_params,
        use_sample_data=True,
        interactive=True,
        save_plots=True,
        peak_threshold=80  # Uncomment to enable peak shaving
    )
    
    print("\nSimulation complete!")
