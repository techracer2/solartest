import pyomo.environ as pyomo
import pandas as pd
import matplotlib.pyplot as plt

def load_data_from_csv(solar_file, load_file):
    """
    Load solar and load data from CSV files with 15-minute timestamps.
    """
    # Load CSV files into pandas DataFrames
    solar_df = pd.read_csv(solar_file)
    load_df = pd.read_csv(load_file)
    
    # Extract power values from DataFrames
    # Assuming the CSV files have a column with the power values
    solar_data = solar_df['power'].tolist()
    load_data = load_df['power'].tolist()
    
    return solar_data, load_data

def optimization_model(solar_data, load_data, diesel_max, grid_limit, bess_params, time_steps, grid_price=0.15, diesel_price=0.3):
    """
    Optimize power dispatch for a star topology network.
    """
    # Create a new Pyomo model
    model = pyomo.ConcreteModel()
    
    # Define the set of time steps
    model.T = pyomo.Set(initialize=range(time_steps))
    
    # Define parameters
    # Solar power data for each time step
    model.solar_data = pyomo.Param(model.T, initialize={t: solar_data[t] for t in model.T})
    # Load data for each time step
    model.load_data = pyomo.Param(model.T, initialize={t: load_data[t] for t in model.T})
    # Maximum diesel generator output
    model.diesel_max = pyomo.Param(initialize=diesel_max)
    # Maximum grid import/export limit
    model.grid_limit = pyomo.Param(initialize=grid_limit)
    # Battery capacity
    model.bess_capacity = pyomo.Param(initialize=bess_params['capacity'])
    # Maximum battery charging rate
    model.bess_charge_max = pyomo.Param(initialize=bess_params['charge_max'])
    # Maximum battery discharging rate
    model.bess_discharge_max = pyomo.Param(initialize=bess_params['discharge_max'])
    # Battery charge/discharge efficiency
    model.bess_efficiency = pyomo.Param(initialize=bess_params['efficiency'])
    # Minimum battery state of charge (as a fraction of capacity)
    model.bess_min_soc = pyomo.Param(initialize=bess_params['min_soc'])
    # Maximum battery state of charge (as a fraction of capacity)
    model.bess_max_soc = pyomo.Param(initialize=bess_params['max_soc'])
    # Initial battery state of charge
    model.bess_initial_soc = pyomo.Param(initialize=bess_params['initial_soc'])
    # Time step duration (15 minutes in hours)
    model.time_step = pyomo.Param(initialize=0.25)
    # Price of electricity from the grid
    model.grid_price = pyomo.Param(initialize=grid_price)
    # Price of electricity from diesel generator
    model.diesel_price = pyomo.Param(initialize=diesel_price)
    
    # Define variables
    # Power from solar panels
    model.p_solar = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)
    # Power from diesel generator
    model.p_diesel = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)
    # Power from/to grid (positive = import, negative = export)
    model.p_grid = pyomo.Var(model.T, domain=pyomo.Reals)
    # Power imported from grid
    model.p_grid_import = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)
    # Power exported to grid
    model.p_grid_export = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)
    # Power to/from battery (positive = charging, negative = discharging)
    model.p_bess = pyomo.Var(model.T, domain=pyomo.Reals)
    # Battery state of charge
    model.soc = pyomo.Var(model.T, domain=pyomo.NonNegativeReals)
    
    # Binary variables for control
    # 1 if diesel generator is on, 0 otherwise
    model.diesel_on = pyomo.Var(model.T, domain=pyomo.Binary)
    # 1 if exporting to grid, 0 otherwise
    model.grid_export = pyomo.Var(model.T, domain=pyomo.Binary)
    # 1 if charging battery, 0 if discharging
    model.bess_charging = pyomo.Var(model.T, domain=pyomo.Binary)
    
    # Define objective function
    def obj_rule(model):
        # Cost of importing electricity from the grid
        grid_cost = sum(model.p_grid_import[t] * model.grid_price for t in model.T)
        # Revenue from exporting electricity to the grid
        grid_revenue = sum(model.p_grid_export[t] * model.grid_price for t in model.T)
        # Cost of generating electricity with diesel generator
        diesel_cost = sum(model.p_diesel[t] * model.diesel_price for t in model.T)
        # Total cost = grid cost + diesel cost - grid revenue
        return grid_cost + diesel_cost - grid_revenue
    
    # Set the objective to minimize total cost
    model.objective = pyomo.Objective(rule=obj_rule, sense=pyomo.minimize)
    
    # Define constraints
    
    # Grid decomposition constraint: p_grid = p_grid_import - p_grid_export
    def grid_decomposition_rule(model, t):
        return model.p_grid[t] == model.p_grid_import[t] - model.p_grid_export[t]
    
    model.grid_decomposition = pyomo.Constraint(model.T, rule=grid_decomposition_rule)
    
    # Power balance constraint: p_solar + p_diesel + p_grid = p_load + p_bess
    def power_balance_rule(model, t):
        return model.p_solar[t] + model.p_diesel[t] + model.p_grid[t] - model.load_data[t] - model.p_bess[t] == 0
    
    model.power_balance = pyomo.Constraint(model.T, rule=power_balance_rule)
    
    # Solar power constraint: p_solar <= solar_data
    def solar_constraint_rule(model, t):
        return model.p_solar[t] <= model.solar_data[t]
    
    model.solar_constraint = pyomo.Constraint(model.T, rule=solar_constraint_rule)
    
    # Diesel generator constraint: p_diesel <= diesel_max * diesel_on
    def diesel_constraint_rule(model, t):
        return model.p_diesel[t] <= model.diesel_max * model.diesel_on[t]
    
    model.diesel_constraint = pyomo.Constraint(model.T, rule=diesel_constraint_rule)
    
    # Grid export constraint: p_grid_export <= grid_limit * grid_export
    def grid_export_constraint_rule(model, t):
        return model.p_grid_export[t] <= model.grid_limit * model.grid_export[t]
    
    model.grid_export_constraint = pyomo.Constraint(model.T, rule=grid_export_constraint_rule)
    
    # Grid import constraint: p_grid_import <= grid_limit * (1 - grid_export)
    def grid_import_constraint_rule(model, t):
        return model.p_grid_import[t] <= model.grid_limit * (1 - model.grid_export[t])
    
    model.grid_import_constraint = pyomo.Constraint(model.T, rule=grid_import_constraint_rule)
    
    # Diesel generator cannot send power to grid: diesel_on + grid_export <= 1
    def diesel_grid_rule(model, t):
        return model.diesel_on[t] + model.grid_export[t] <= 1
    
    model.diesel_grid_constraint = pyomo.Constraint(model.T, rule=diesel_grid_rule)
    
    # BESS charging constraint: p_bess <= bess_charge_max * bess_charging
    def bess_charge_limit_rule(model, t):
        return model.p_bess[t] <= model.bess_charge_max * model.bess_charging[t]
    
    model.bess_charge_limit = pyomo.Constraint(model.T, rule=bess_charge_limit_rule)
    
    # BESS discharging constraint: p_bess >= -bess_discharge_max * (1 - bess_charging)
    def bess_discharge_limit_rule(model, t):
        M = model.bess_discharge_max  # Big-M value
        return model.p_bess[t] >= -M * (1 - model.bess_charging[t])
    
    model.bess_discharge_limit = pyomo.Constraint(model.T, rule=bess_discharge_limit_rule)
    
    # BESS state of charge dynamics: soc[t] = soc[t-1] + p_bess[t] * efficiency * time_step
    def soc_dynamics_rule(model, t):
        if t == 0:
            # For the first time step, use the initial SOC
            return model.soc[t] == model.bess_initial_soc + model.p_bess[t] * model.bess_efficiency * model.time_step
        else:
            # For subsequent time steps, use the SOC from the previous time step
            return model.soc[t] == model.soc[t-1] + model.p_bess[t] * model.bess_efficiency * model.time_step
    
    model.soc_dynamics = pyomo.Constraint(model.T, rule=soc_dynamics_rule)
    
    # BESS state of charge lower limit: soc[t] >= min_soc * capacity
    def soc_lower_limit_rule(model, t):
        return model.soc[t] >= model.bess_min_soc * model.bess_capacity
    
    model.soc_lower_limit = pyomo.Constraint(model.T, rule=soc_lower_limit_rule)
    
    # BESS state of charge upper limit: soc[t] <= max_soc * capacity
    def soc_upper_limit_rule(model, t):
        return model.soc[t] <= model.bess_max_soc * model.bess_capacity
    
    model.soc_upper_limit = pyomo.Constraint(model.T, rule=soc_upper_limit_rule)
    
    # Solve the model using Gurobi
    solver = pyomo.SolverFactory('gurobi')
    results = solver.solve(model)
    
    # Extract results
    result = {
        'p_solar': [model.p_solar[t].value for t in model.T],
        'p_diesel': [model.p_diesel[t].value for t in model.T],
        'p_grid': [model.p_grid[t].value for t in model.T],
        'p_grid_import': [model.p_grid_import[t].value for t in model.T],
        'p_grid_export': [model.p_grid_export[t].value for t in model.T],
        'p_bess': [model.p_bess[t].value for t in model.T],
        'soc': [model.soc[t].value for t in model.T],
        'diesel_on': [model.diesel_on[t].value for t in model.T],
        'grid_export': [model.grid_export[t].value for t in model.T],
        'bess_charging': [model.bess_charging[t].value for t in model.T],
        'objective': model.objective()
    }
    
    return model, result

def run_optimization(solar_file, load_file, diesel_max, grid_limit, bess_params, grid_price=0.15, diesel_price=0.3):
    """
    Run the optimization model and visualize results.
    """
    # Load data from CSV files
    solar_data, load_data = load_data_from_csv(solar_file, load_file)
    
    # Run optimization
    model, result = optimization_model(solar_data, load_data, diesel_max, grid_limit, bess_params, len(solar_data), grid_price, diesel_price)
    
    # Plot results
    fig, ax = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
    
    # Power flows
    ax[0].plot(result['p_solar'], label='Solar')
    ax[0].plot(result['p_diesel'], label='Diesel')
    ax[0].plot(result['p_grid'], label='Grid')
    ax[0].plot(result['p_bess'], label='BESS')
    ax[0].plot(load_data, label='Load')
    ax[0].axhline(0, color='black', linestyle='-', linewidth=0.5)
    ax[0].set_ylabel('Power (kW)')
    ax[0].legend()
    
    # BESS state of charge
    ax[1].plot(result['soc'], label='State of Charge')
    ax[1].set_ylabel('SOC (kWh)')
    ax[1].legend()
    
    # Control variables
    ax[2].plot(result['diesel_on'], label='Diesel On')
    ax[2].plot(result['grid_export'], label='Grid Export')
    ax[2].plot(result['bess_charging'], label='BESS Charging')
    ax[2].set_xlabel('Time Step')
    ax[2].set_ylabel('Status')
    ax[2].legend()
    
    plt.tight_layout()
    plt.show()
    
    return model, result

if __name__ == "__main__":
    # Example parameters
    diesel_max = 100  # kW
    grid_limit = 200  # kW
    
    # Battery parameters
    bess_params = {
        'capacity': 500,  # kWh
        'charge_max': 100,  # kW
        'discharge_max': 100,  # kW
        'efficiency': 0.95,  # Efficiency
        'min_soc': 0.1,  # Minimum state of charge (fraction)
        'max_soc': 0.9,  # Maximum state of charge (fraction)
        'initial_soc': 250  # Initial state of charge (kWh)
    }
    
    # Electricity prices
    grid_price = 0.15  # $/kWh
    diesel_price = 0.3  # $/kWh
    
    # Run optimization
    model, result = run_optimization('solar_data.csv', 'load_data.csv', diesel_max, grid_limit, bess_params, grid_price, diesel_price)
    
    # Print objective value
    print(f"Objective value: ${result['objective']:.2f}")
